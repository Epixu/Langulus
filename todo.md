- cleanup the concept of CT::POD
- experiment with using RTTI::SomeTrait; and detecting those upon reflection, instead of using macros; traits can have more advanced options on how a base can propagate to derived classes, etc.
- rename Traits to Tags?
- rename Any to Many, and make Any specialized for one element only?
- mInfo in maps moves around to first map entry, so that iterations always beging with the first pair
- implement ordered maps and sets using an ordering array of indices after the mInfo array - that way we can directly transfer maps between ordered/unordered variations without any trouble
- use redundant map data (mValues.mCount and mValues.mReserved) for keeping track of ordering array
- map and set iterations tend to iterate to the end of mInfo, despite having gone past the inserted mCount
- when deducing this is implemented for gcc, use it to reduce a plethora of const/mutable function equivalents, and use if consteval
- add multiplication operators to meta types to multiply by their size
- remove CT::Inner duplicated concepts, use Decay when needed to use the non-inner version
- ALL CONCEPTS NEED TESTS, because i just fixed a plethora of logical mistakes in them. can's stress this enough.
- Ditch monocast nonsense, and instead add Shallow semantic that affects whether verbs are executed deeply or not?
- In future standards, make sure we exclude reflected bases that don't qualify as 'direct'; route imposed bases through a semantic instead
- Many of the containers call two destructors instead of one, inherit directly from Block/BlockMap/BlockSet to avoid it
- Block, BlockMap, BlockSet are unsafe when inserting/removing with more than one ref - the newly implemented Copy/Refer semantics will help branch out the container before touching any memory
- Test a block that contains multiple different interleaved groups of coalesced elements for a pretty nasty bad block destruction corner case